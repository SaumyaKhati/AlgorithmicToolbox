import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.ArrayList;public class Main {    public static void main(String[] args) throws Exception{        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        //for problem 1//        int money = Integer.parseInt(br.readLine());//        System.out.println(problemOne(money));        //for problem 2        int number = Integer.parseInt(br.readLine());        problemTwo(number);    }    /**     * Straightforward implementation of the example given in the lesson     * @param money amt. required to be turned into change     * @return change amount for money     *///    private static int problemOne(int money){////        int numCoins; //keep track of coin numbers per coin denomination.////        int[] minNumCoins = new int[money+1]; //store min. change needed for each num up to total money//        minNumCoins[0]=0; //0 change needed for 0 money////        int [] coinTypes = {1, 3, 4}; //store coin denominations////        //go through entire MNC array and store min for each value as well as use prev. stored val. to calculate current one//        for(int j = 1; j < minNumCoins.length; j++){////            //change at the start must be "infinite" so that any calc. number after this is always smaller.//            minNumCoins[j] =  999999999;////            //go through all coin denominations to find the one that results in min. combo//            for(int i = 0; i < 3; i++){////                //if j, ie. current money value is greater than coin denomination then calc. change//                if(j >= coinTypes[i]){////                    numCoins = minNumCoins[j-coinTypes[i]]+1; //number is equal to 1 plus money-coin denomination as taught.//                    if(numCoins < minNumCoins[j]){//                        minNumCoins[j]=numCoins; //if numCoins is smaller then stored val, then substitute.//                    }//                }//            }//        }//        return minNumCoins[money]; //return change value for money amount.//    }//end problem 1    /**     * For this problem, we use the same method we used in 1 to calculate the min. moves for number. Once we have that,     * we can use a while loop to "actually" calc. and store the intermediary values. We go backwards, starting from     * number itself, then check which option (number/3, number/2 or number-1) has the min. # of moves and so forth     * until we reach 1. At that point, we print all the values stored backwards starting from 1.     * @param number val we need to reach from 1 using fewest combo of given moves (*2, *3 or +1).     */    private static void problemTwo(int number){        int [] moves = new int[number+1]; //storing min. moves for all val. up till number        moves[1]=0; //for 1, its 0.        //iterating through all # uptill number val. and using prev. calc. values to calc. curr val.        for(int i = 2; i < number+1; i++){            moves[i]=999999999; //moves at beginning is large so any # afterwards will be stored.            int moveNum; //keep track of move number            //variables to help keep track of # of moves after using each operation            int a= 999999, b = 999999, c = 999999;            //iterate through all operations (*3, *2, +1)            for(int j = 0; j < 3; j++){                //go through the "*2" option. We divide by 2 in order to backtrack to prev. value (if divisible)                if(j == 1 && i%2 == 0){                    //if i is already 2, then min. # of moves will simply be 1.                    if(i ==2){                        a=1;                    }                    else {                        moveNum = moves[i/2]+1;                        a= moveNum;                    }                }                //go through "*3" option. If i is only 3, then we know # of operations is only 1.                else if(j ==2 && i%3 == 0){                    if(i ==3){                        b=1;                    }                    else {                        moveNum = moves[i/3]+1;                        b=moveNum;                    }                }                //otherwise, if i is not divisible by 2 or 3 (or is smaller) then, the only valid operation is "+1" which                //means we do -1 since we want to "backtrack"                else {                    moveNum = moves[i-1]+1;                    c=moveNum;                }            }            //Whichever operation results in fewest # of moves will be the minimum for i.            moves[i] = Math.min(a, Math.min(b,c));        }        //print out min # of operations for number given.        System.out.println(moves[number]);        ArrayList<Integer> path = new ArrayList <>(); //list to store the intermediary values.        path.add(number); //add original number since we start from there.        /*        Since we now have min. # of moves for each val up till number, we can go backwards to find the intermediate values.        We do this by using the operations and choosing the one resulting in next least # of moves. We store that value, and        keep repeating and going backwards till number is 1 at which point we have all of the values.         */        while(number > 1){            //variables to store the min. val for each number that we get after doing the repsective operation.            int div3Num = 999999 , div2Num = 999999;            int minus1Num = moves[number-1]+1;            //get the min # of moves for number/2.            if(number %2 == 0){                div2Num = moves[number/2]+1;            }            //get the min # of moves for number/2.            if(number %3 == 0){                div3Num=moves[number%3]+1;            }            //Out of the three move # we calculated from the following operations: (number/3), (number/2) and (number-1),            // choose the minimum.            int min = Math.min(div3Num, Math.min(div2Num, minus1Num));            //Find out which operation resulted in "min". # of moves, and do the operation on number.            if (min == div3Num) {                number/=3;            }            else if(min == div2Num){                number/=2;            }            else {                number-=1;            }            path.add(number); //store the "new", reduced number and keep going backwards.        }        //print out all intermediary values as well as 1 and number itself.        for(int i = path.size()-1; i >= 0; i--){            System.out.print(path.get(i) + " ");        }    }//end problem 2    }