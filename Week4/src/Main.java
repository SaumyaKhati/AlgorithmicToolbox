import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.*;public class Main {    public static void main(String[] args) throws Exception{	    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        //for problem 1//        String[]line1 = br.readLine().split(" ");//        String[]line2 = br.readLine(). split(" ");////        int lengthA = Integer.parseInt(line1[0]), lengthB = Integer.parseInt(line2[0]);////        int[]set = new int[lengthA], keys = new int[lengthB];////        for(int i =0; i < lengthA; i++){//            set[i] = Integer.parseInt(line1[i+1]);//        }////        for(int i =0; i<lengthB; i++){//            keys[i] = Integer.parseInt(line2[i+1]);//        }////        System.out.println(problemOne(set, keys));        //for problem 2//        int n = Integer.parseInt(br.readLine());//        HashMap<Integer,Integer> count = new HashMap <>();//        String[]line = br.readLine().split(" ");////        //Here, we add every new element, and increase count of previously seen elements by one.//        for(int i = 0; i < n; i++){//            int key = Integer.parseInt(line[i]);//            if(count.containsKey(key)){//                count.put(key, count.get(key)+1);//            }//            else {//                count.put(key, 1);//            }//        }//        System.out.println(problemTwo(count, n));        //for problem 3        int n = Integer.parseInt(br.readLine());        ArrayList<Integer> set = new ArrayList <>();        String[]line = br.readLine().split(" ");        //adding numbers to list.        for(int i =0; i < n; i++){            set.add(Integer.parseInt(line[i]));        }        set=randomizedQuickSortProblem3(set, 0, set.size());        for (Integer a : set) {            System.out.print(a + " ");        }    }    /**      Fairly straightforward implementation of the binary search code taught in the video lessons. You use a for loop      to go through all keys and output the results (in this case I will use a StringBuilder and append the result.      In this case, I will not reimplement the binary search code since we have learned it already. Instead I will use      the standard Arrays library which comes with a binary search method.      @param set - numbers to search through     * @param keys- keys to use for set and outputting resutls     * @return  String containing search results for all keys     *///    private static String problemOne(int[]set, int[]keys){//        StringBuilder answer = new StringBuilder();////        for (int key : keys) {////            int result = Arrays.binarySearch(set, key);////            //ensuring that if key is not present in set, it will output -1 not -6 or any other number.//            if(result <0) {//                answer.append("-1 ");//            }//            else {//                answer.append(result).append(" "); //space is needed between indices as depicted in the test case.//            }//        }////        return answer.toString(); //returns full string//    }    /**     * For this problem, you do not need a divide and conquer. It can be solved in O(n) time using HashMaps and simply     * updating count for each "key" ie. unique number you find and add to the map. Once you have counts for all unique     * numbers, we iterate to find the key w. max "count" then return 1 or 0 depending on if its a majority.     *     * @param count is the hashmap containing keys which are all the unique numbers and pair value which is # of times     *              key appeared     * @return index of max value if its majority or 0     *///    private static Integer problemTwo(HashMap<Integer, Integer> count, int n){////        //setting maxCount as the #of appearances of first key.//        int maxCount = (int)count.keySet().toArray()[0];////        //getting max value.//        for(Integer a: count.keySet()){//            if(count.get(a) > count.get(maxCount)){//                maxCount=a;//            }//        }////        //if max value is the majority(ie. greater than n/2) then return 1, otherwise return 0.//        if(count.get(maxCount) > n/2){//            return 1;//        }//        else {//            return 0;//        }//    }    /**     * For this problem, we simply implement the Quicksort method taught in the videos with the partition3 method     * where it returns m1 and m2 pivot elements where all elements between m1 and m2 are equal to the pivot.     * @param set list containing the integers     */    private static ArrayList<Integer> randomizedQuickSortProblem3(ArrayList<Integer> set, int l, int r){        if(l >= r){            return set;        }        //selecting random pivot between the constraints (l and r).        int k = (int)(Math.random()*(r-l))+l;        //swapping l and k such that the pivot is the first element.        Collections.swap(set, l, k);        int[]pivots = partition3(set, l, r);        //quicksorting the two other sides respective to the pivot range. Since this can be independant,        //we can use result of one for the other.        return randomizedQuickSortProblem3(randomizedQuickSortProblem3(set, l, pivots[0]),pivots[1]+1,r);    }    /**     * This is the partition3 method that I have developed. The logic is based upon the original partition method     * with a few modifications.     * @param set contains the integers     * @param l leftmost index (inclusive)     * @param r rightmost index (not inclusive!)     * @return int array containing the two pivots     */    private static int[] partition3(ArrayList<Integer> set, int l, int r) {        int m1 = l, m2 = m1, pivot = set.get(l);        //since pivot is l, we start the loop from l+1        for(int i = l+1; i <r; i++){            //if the next number is less than pivot, it should be before m1 therefore swap after incrementing.            if(set.get(i) < pivot){                m1++;                /*                We need to be aware of one special case which is if m1++ results in the "territory" of elements that are                equal to the pivot. If that is the case, swapping m1 and i directly will result in an incorrect sort.                Therefore, we must first increment m2 and then swap i with m2 so that when we swap m1 and m2, the element                equal to the pivot is between the range of m1 and m2 which is what we want.                Since all elements from m1-m2(inclusive) is equal to the pivot.                 */                if(set.get(m1) == pivot){                    m2++;                    Collections.swap(set, m2, i);                    Collections.swap(set, m1,m2);                }                else {                    Collections.swap(set, m1, i);                }            }            //if element is equal to pivot, swap with m2 after increment.            else if(set.get(i) == pivot){                m2++;                Collections.swap(set, m2, i);            }            /*            if element is greater than pivot, then it needs to be ahead of m2, therefore, swap it with m2+1 but do            not increment m2.             */            else {                Collections.swap(set, m2+1, i);            }            //m2 needs to be at least equal to m1. Therefore, if there are no elements equal to pivot (ie. m2 has not            //been incremented), then let m2=m1.            if(m2 < m1){                m2=m1;            }        }        //Finally, we need to swap l and m1 so that m1-m2 (inclusive) only contains elements equal to pivot.        Collections.swap(set, l, m1);        return new int[]{m1, m2}; //returns the two pivots as an int array.    }}