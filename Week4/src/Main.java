import java.io.BufferedReader;import java.io.InputStreamReader;import java.lang.reflect.Array;import java.util.*;public class Main {    public static void main(String[] args) throws Exception{	    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        //for problem 1//        String[]line1 = br.readLine().split(" ");//        String[]line2 = br.readLine(). split(" ");////        int lengthA = Integer.parseInt(line1[0]), lengthB = Integer.parseInt(line2[0]);////        int[]set = new int[lengthA], keys = new int[lengthB];////        for(int i =0; i < lengthA; i++){//            set[i] = Integer.parseInt(line1[i+1]);//        }////        for(int i =0; i<lengthB; i++){//            keys[i] = Integer.parseInt(line2[i+1]);//        }////        System.out.println(problemOne(set, keys));        //for problem 2//        int n = Integer.parseInt(br.readLine());//        HashMap<Integer,Integer> count = new HashMap <>();//        String[]line = br.readLine().split(" ");////        //Here, we add every new element, and increase count of previously seen elements by one.//        for(int i = 0; i < n; i++){//            int key = Integer.parseInt(line[i]);//            if(count.containsKey(key)){//                count.put(key, count.get(key)+1);//            }//            else {//                count.put(key, 1);//            }//        }//        System.out.println(problemTwo(count, n));        //for problem 3//        int n = Integer.parseInt(br.readLine());//        ArrayList<Integer> set = new ArrayList <>();//        String[]line = br.readLine().split(" ");////        //adding numbers to list.//        for(int i =0; i < n; i++){//            set.add(Integer.parseInt(line[i]));//        }////        set=randomizedQuickSortProblem3(set, 0, set.size());////        for (Integer a : set) {//            System.out.print(a + " ");//        }        //for problem 4//        int n = Integer.parseInt(br.readLine());//        ArrayList<Integer> set = new ArrayList <>();//        String[]line = br.readLine().split(" ");////        //adding numbers to list.//        for(int i =0; i < n; i++){//            set.add(Integer.parseInt(line[i]));//        }////        Info start = new Info(set, 0);//        Info end = mergeSortProblemFour(start);//        System.out.println(end.getInversions());        //for problem 5//        String [] info = br.readLine().split(" ");//        int s = Integer.parseInt(info[0]), p = Integer.parseInt(info[1]);////        ArrayList<Pair> data = new ArrayList <>();////        for(int i =0; i < s; i++){//            String [] line = br.readLine().split(" ");//            data.add(new Pair(Integer.parseInt(line[0]), "l"));//            data.add(new Pair(Integer.parseInt(line[1]), "r"));//        }////        String [] line = br.readLine().split(" ");////        TreeMap<Integer,Integer> pCount = new TreeMap <>();//        ArrayList<Integer> original = new ArrayList <>();////        for(String a: line){//            data.add(new Pair(Integer.parseInt(a), "p"));//            pCount.put(Integer.parseInt(a), 0);//            original.add(Integer.parseInt(a));//        }////        data.sort(Comparator.comparingInt(Pair::getNumber));////        for (Pair aData : data) {//            System.out.println(aData.getNumber() + "," + aData.getDataType());//        }////        System.out.println(problemFive(data, pCount, original));        testLottery();    }    /**      Fairly straightforward implementation of the binary search code taught in the video lessons. You use a for loop      to go through all keys and output the results (in this case I will use a StringBuilder and append the result.      In this case, I will not reimplement the binary search code since we have learned it already. Instead I will use      the standard Arrays library which comes with a binary search method.      @param set - numbers to search through     * @param keys- keys to use for set and outputting resutls     * @return  String containing search results for all keys     *///    private static String problemOne(int[]set, int[]keys){//        StringBuilder answer = new StringBuilder();////        for (int key : keys) {////            int result = Arrays.binarySearch(set, key);////            //ensuring that if key is not present in set, it will output -1 not -6 or any other negative number.//            if(result <0) {//                answer.append("-1 ");//            }//            else {//                answer.append(result).append(" "); //space is needed between indices as depicted in the test case.//            }//        }////        return answer.toString(); //returns full string//    }    /**     * For this problem, you do not need a divide and conquer. It can be solved in O(n) time using HashMaps and simply     * updating count for each "key" ie. unique number you find and add to the map. Once you have counts for all unique     * numbers, we iterate to find the key w. max "count" then return 1 or 0 depending on if its a majority.     *     * @param count is the hashmap containing keys which are all the unique numbers and pair value which is # of times     *              key appeared     * @return index of max value if its majority or 0     *///    private static Integer problemTwo(HashMap<Integer, Integer> count, int n){////        //setting maxCount as the #of appearances of first key.//        int maxCount = (int)count.keySet().toArray()[0];////        //getting max value.//        for(Integer a: count.keySet()){//            if(count.get(a) > count.get(maxCount)){//                maxCount=a;//            }//        }////        //if max value is the majority(ie. greater than n/2) then return 1, otherwise return 0.//        if(count.get(maxCount) > n/2){//            return 1;//        }//        else {//            return 0;//        }//    }    /**     * For this problem, we simply implement the Quicksort method taught in the videos with the partition3 method     * where it returns m1 and m2 pivot elements where all elements between m1 and m2 are equal to the pivot.     * @param set list containing the integers     *///    private static ArrayList<Integer> randomizedQuickSortProblem3(ArrayList<Integer> set, int l, int r){//        if(l >= r){//            return set;//        }////        //selecting random pivot between the constraints (l and r).//        int k = (int)(Math.random()*(r-l))+l;////        //swapping l and k such that the pivot is the first element.//        Collections.swap(set, l, k);////        int[]pivots = partition3(set, l, r);////        //quicksorting the two other sides respective to the pivot range. Since this can be independant,//        //we can use result of one for the other.//        return randomizedQuickSortProblem3(randomizedQuickSortProblem3(set, l, pivots[0]),pivots[1]+1,r);//    }    /**     * This is the partition3 method that I have developed. The logic is based upon the original partition method     * with a few modifications.     * @param set contains the integers     * @param l leftmost index (inclusive)     * @param r rightmost index (not inclusive!)     * @return int array containing the two pivots     *///    private static int[] partition3(ArrayList<Integer> set, int l, int r) {//        int m1 = l, m2 = m1, pivot = set.get(l);////        //since pivot is l, we start the loop from l+1//        for(int i = l+1; i <r; i++){////            //if the next number is less than pivot, it should be before m1 therefore swap after incrementing.//            if(set.get(i) < pivot){//                m1++;////                /*//                We need to be aware of one special case which is if m1++ results in the "territory" of elements that are//                equal to the pivot. If that is the case, swapping m1 and i directly will result in an incorrect sort.//                Therefore, we must first increment m2 and then swap i with m2 so that when we swap m1 and m2, the element//                equal to the pivot is between the range of m1 and m2 which is what we want.//                Since all elements from m1-m2(inclusive) is equal to the pivot.//                 *///                if(set.get(m1) == pivot){//                    m2++;//                    Collections.swap(set, m2, i);////                    Collections.swap(set, m1,m2);//                }//                else {//                    Collections.swap(set, m1, i);//                }//            }//            //if element is equal to pivot, swap with m2 after increment.//            else if(set.get(i) == pivot){//                m2++;//                Collections.swap(set, m2, i);////            }////            /*//            if element is greater than pivot, then it needs to be ahead of m2, therefore, swap it with m2+1 but do//            not increment m2.//             *///            else {//                Collections.swap(set, m2+1, i);//            }////            //m2 needs to be at least equal to m1. Therefore, if there are no elements equal to pivot (ie. m2 has not//            //been incremented), then let m2=m1.//            if(m2 < m1){//                m2=m1;//            }//        }////        //Finally, we need to swap l and m1 so that m1-m2 (inclusive) only contains elements equal to pivot.//        Collections.swap(set, l, m1);////        return new int[]{m1, m2}; //returns the two pivots as an int array.//    }    /**     * For this problem, we need to implement the mergesort algorithm from the lessons with an added parameter     * to keep track of the inversions made during Merge. Due to the fact that Java does not allow for the return of two     * values, I decided to create an Info class that stores both the set (ie. arraylist) of integers and the inversion     * count. Hence, instead of returning values, I will return an instance of Info class that holds these values.     *     * @param information an instance of Class Info that contains the arrayList of numbers to sort and the inversion count     * @return instance of Info which holds relevant information     *///     private static Info mergeSortProblemFour(Info information){////         //if array size is one, then return the array (ie. instance of the class).//         if(information.getNumberSet().size() == 1){//             return information;//         }////         int m = information.getNumberSet().size()/2; //splitting array into half.//         int end = information.getNumberSet().size(); //getting right max index of subarray.////         //splitting original set into sub arrays of left and right side elements respectively.//         ArrayList<Integer> leftSet = new ArrayList <>(information.getNumberSet().subList(0, m));//         ArrayList<Integer> rightSet = new ArrayList <>(information.getNumberSet().subList(m, end));////         //calling mergesort on those respective sides and storing it into two new instances l and r. Note that//         //the number of inversions needs to remain the same as original array therefore, we use getInversions() method.//         Info l = mergeSortProblemFour(new Info(leftSet, information.getInversions()));//         Info r = mergeSortProblemFour(new Info(rightSet, information.getInversions()));////         return merge(l,r); //return the resulting "array" + number of inversions as another instance.//    }    /**     * Method merges the two integer sets from Info instances l and r, and then updates total number of inversions.     * @param l instance of Info class that contains the left-side elements of original array     * @param r instance of Info class containing the right-side elements of original array     * @return instance of Info that contains both the merged array and the updated # of inversions.     *///    private static Info merge(Info l, Info r) {////        //get the two stored arrayLists using getter methods.//        ArrayList<Integer> left = l.getNumberSet();//        ArrayList<Integer> right = r.getNumberSet();//////        ArrayList<Integer> merged = new ArrayList <>(); //instantiating the merged ArrayList////        //Getting current number of inversions (before merging), which is the sum of the total inversions for left and//        //right sub-arrays respectively.//        int currInversions = l.getInversions()+r.getInversions();//////        //implementing a modified version of the pseudo-code taught in the lessons.//        while(left.size() > 0 && right.size() > 0){////            //getting first elements of both arrays.//            int a = left.get(0);//            int b = right.get(0);////            //if a is smaller or equal, no inversions are needed. Thus, add a to merged and remove from left set.//            if(a <= b){//                merged.add(a);//                left.remove(0);//            }//            else {//                //continue iterating through right set until a is smaller or equal to b.//                while(a > b){////                    //remove b from right set and add to merged.//                    merged.add(b);//                    right.remove(0);////                    /*//                    Note: if a is larger than b, then entire left set is larger since l(0) <= l(1) <= l(2) ... <= l(m-1).//                    Therefore, the number of pairs (a,b) such that a > b will be equal to the entire left set for that//                    particular b value. This in turn means that currInversions must be increased by the left set size//                    since that is the total number of "inversions" or pairs containing that b value.//                     *///                    currInversions+= left.size();////                    //if right set is now empty, due to the prior removal of b, then we break. Otherwise, b is again the//                    //first value.//                    if(right.size() > 0) b = right.get(0);//                    else break;//                }//            }//        }////        //add remaining elements of left and right set.//        if(left.size() > 0){//            merged.addAll(left);//            left.clear();//        }////        if(right.size() > 0){//            merged.addAll(right);//            right.clear();//        }////        //return new instance of Info with the merged array and updated currInversions value.//        return new Info(merged, currInversions);//    }    /**     *     */    private static String problemFive(ArrayList<Pair> data, TreeMap<Integer, Integer> pCount, ArrayList<Integer>original){        int segmentCount = 0;        ArrayList<Integer> inSeg = new ArrayList <>();        for(int i = 0; i < data.size(); i++){            switch (data.get(i).getDataType()) {                case "l":                    segmentCount++;                    break;                case "r":                    segmentCount--;                    inSeg.clear();                    break;                default:                    if(i > 0){                        Pair c = data.get(i);                        Pair before= data.get(i-1);                        if(before.getNumber() == c.getNumber() && before.getDataType().equals("r")){                            int q = data.get(i).getNumber();                            pCount.put(q, pCount.get(q) + 1);                        }                    }                    if (segmentCount != 0) {                        inSeg.add(data.get(i).getNumber());                    }                    break;            }            for (Integer num : inSeg) {                pCount.put(num, pCount.get(num) + segmentCount);            }            inSeg.clear();        }        StringBuilder sb = new StringBuilder();        for (Integer num : original) {            sb.append(pCount.get(num)).append(" ");        }        return sb.toString();    }    private static void testLottery(){        int runs = 20;        for(int r = 0; r < runs; r++){            int segments = (int)(Math.random()*10+1), points = (int)(Math.random()*10+1);            ArrayList<Pair> data = new ArrayList <>();            int[][] seg = new int[segments][2];            for(int i =0; i < segments; i++){                int start = new Random().nextInt(100 - -100) -100;                int end = new Random().nextInt(200 - start)+start;                data.add(new Pair(start, "l"));                data.add(new Pair(end, "r"));                seg[i][0]=start;                seg[i][1]=end;            }            TreeMap<Integer,Integer> pCount = new TreeMap <>();            ArrayList<Integer> original = new ArrayList <>();            for(int i = 0; i < points; i++){                int p = new Random().nextInt(100- -100)-100;                data.add(new Pair(p, "p"));                pCount.put(p, 0);                original.add(p);            }            data.sort(Comparator.comparingInt(Pair::getNumber));            String problemFiveDC = problemFive(data, pCount, original);            String pFiveNaive = lotteryNaive(seg, original);            if(problemFiveDC.equals(pFiveNaive)){                System.out.println("OK");            }            else {                System.out.println("points = " + original);                System.out.println("problemFiveDC = " + problemFiveDC);                System.out.println("probFiveNaive = " + pFiveNaive);                for(int i = 0; i < seg.length; i++){                    System.out.print(Arrays.toString(seg[i]) + " ");                }                System.out.println();            }        }    }    private static String lotteryNaive(int[][]seg, ArrayList<Integer>points){        StringBuilder sb = new StringBuilder();        for (Integer point : points) {            int count = 0;            for (int[] pair : seg) {                if (point <= pair[1] && point >= pair[0]) {                    count++;                }            }            sb.append(count).append(" ");        }        return sb.toString();    }}//end of class main/** * Class Info needed for problem 3 in order to return two different data types (# of inversions and integer set) *///class Info{////    //fields represent the values needed to return by the method//    private ArrayList<Integer> numberSet;//    private int inversions;////    //constructor used to set filed values//    Info(ArrayList<Integer> set, int i){//        this.numberSet=set;//        this.inversions=i;//    }////    //getter methods for integer set and inversion count//    int getInversions(){//        return inversions;//    }//    ArrayList<Integer> getNumberSet(){//        return numberSet;//    }//}class Pair {    private int number;    private String dataType;    Pair(int n, String t){        this.number=n;        this.dataType=t;    }    int getNumber() { return number; }    String getDataType() { return dataType; }}