import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.Arrays;import java.util.HashMap;import java.util.Set;public class Main {    public static void main(String[] args) throws Exception{	    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        //for problem 1//        String[]line1 = br.readLine().split(" ");//        String[]line2 = br.readLine(). split(" ");////        int lengthA = Integer.parseInt(line1[0]), lengthB = Integer.parseInt(line2[0]);////        int[]set = new int[lengthA], keys = new int[lengthB];////        for(int i =0; i < lengthA; i++){//            set[i] = Integer.parseInt(line1[i+1]);//        }////        for(int i =0; i<lengthB; i++){//            keys[i] = Integer.parseInt(line2[i+1]);//        }////        System.out.println(problemOne(set, keys));        //for problem 2//        int n = Integer.parseInt(br.readLine());//        HashMap<Integer,Integer> count = new HashMap <>();//        String[]line = br.readLine().split(" ");////        //Here, we add every new element, and increase count of previously seen elements by one.//        for(int i = 0; i < n; i++){//            int key = Integer.parseInt(line[i]);//            if(count.containsKey(key)){//                count.put(key, count.get(key)+1);//            }//            else {//                count.put(key, 1);//            }//        }//        System.out.println(problemTwo(count, n));        //for problem 3    }    /**      Fairly straightforward implementation of the binary search code taught in the video lessons. You use a for loop      to go through all keys and output the results (in this case I will use a StringBuilder and append the result.      In this case, I will not reimplement the binary search code since we have learned it already. Instead I will use      the standard Arrays library which comes with a binary search method.      @param set - numbers to search through     * @param keys- keys to use for set and outputting resutls     * @return  String containing search results for all keys     *///    private static String problemOne(int[]set, int[]keys){//        StringBuilder answer = new StringBuilder();////        for (int key : keys) {////            int result = Arrays.binarySearch(set, key);////            //ensuring that if key is not present in set, it will output -1 not -6 or any other number.//            if(result <0) {//                answer.append("-1 ");//            }//            else {//                answer.append(result).append(" "); //space is needed between indices as depicted in the test case.//            }//        }////        return answer.toString(); //returns full string//    }    /**     * For this problem, you do not need a divide and conquer. It can be solved in O(n) time using HashMaps and simply     * updating count for each "key" ie. unique number you find and add to the map. Once you have counts for all unique     * numbers, we iterate to find the key w. max "count" then return 1 or 0 depending on if its a majority.     *     * @param count is the hashmap containing keys which are all the unique numbers and pair value which is # of times     *              key appeared     * @return index of max value if its majority or 0     *///    private static Integer problemTwo(HashMap<Integer, Integer> count, int n){////        //setting maxCount as the #of appearances of first key.//        int maxCount = (int)count.keySet().toArray()[0];////        //getting max value.//        for(Integer a: count.keySet()){//            if(count.get(a) > count.get(maxCount)){//                maxCount=a;//            }//        }////        //if max value is the majority(ie. greater than n/2) then return 1, otherwise return 0.//        if(count.get(maxCount) > n/2){//            return 1;//        }//        else {//            return 0;//        }//    }}